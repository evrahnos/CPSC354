\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Eleas Vrahnos  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
To be written at a later date. 
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

This report is written by Eleas Vrahnos. It details all assignments and progress made in the Programming Languages course at Chapman University. It includes weekly homework assigments, programming assignments, and a final project that demonstrate understanding and application in various class topics.

\section{Homework}\label{homework}

This section will contain my solutions to the weekly homework assignments. 

\subsection{Week 1}

The following is a Python implementation of the Euclidean algorithm:

\begin{lstlisting}[language=Python]
def gcd(a,b):
    while a != b:
        if a > b:
            a = a-b
        else:
            b = b-a
    return a
\end{lstlisting}

\newpage % Temporary page break

\noindent We can test this code by going through the function with a sample input \texttt{gcd(9, 33)}, step by step.

\begin{enumerate}[noitemsep]
  \item \texttt{gcd(9, 33)}
  \begin{itemize}
      \item The function is called, assigning 9 to variable \texttt{a} and 33 to variable \texttt{b}.
  \end{itemize} 
  \item \texttt{while a != b:}
  \begin{itemize}
      \item The while loop condition returns True, so the loop starts.
  \end{itemize}
  \item \texttt{else:}
  \begin{itemize}
      \item \texttt{a > b} (9 $>$ 33) returns False, so the else block executes.
  \end{itemize}
  \item \texttt{b = b-a}
  \begin{itemize}
      \item \texttt{b} is now assigned to $33 - 9$, which is $24$.
  \end{itemize}
  \item \texttt{while a != b:}
  \begin{itemize}
      \item The while loop condition returns True, so the loop starts.
  \end{itemize}
  \item \texttt{else:}
  \begin{itemize}
      \item \texttt{a > b} (9 $>$ 24) returns False, so the else block executes.
  \end{itemize}
  \item \texttt{b = b-a}
  \begin{itemize}
      \item \texttt{b} is now assigned to $24 - 9$, which is $15$.
  \end{itemize}
  \item \texttt{while a != b:}
  \begin{itemize}
      \item The while loop condition returns True, so the loop starts.
  \end{itemize}
  \item \texttt{else:}
  \begin{itemize}
      \item \texttt{a > b} (9 $>$ 15) returns False, so the else block executes.
  \end{itemize}
  \item \texttt{b = b-a}
  \begin{itemize}
      \item \texttt{b} is now assigned to $15 - 9$, which is $6$.
  \end{itemize}
  \item \texttt{while a != b:}
  \begin{itemize}
      \item The while loop condition returns True, so the loop starts.
  \end{itemize}
  \item \texttt{if a > b:}
  \begin{itemize}
      \item \texttt{a > b} (9 $>$ 6) returns True, so the first block executes.
  \end{itemize}
  \item \texttt{a = a-b}
  \begin{itemize}
      \item \texttt{a} is now assigned to $9 - 6$, which is $3$.
  \end{itemize}
  \item \texttt{while a != b:}
  \begin{itemize}
      \item The while loop condition returns True, so the loop starts.
  \end{itemize}
  \item \texttt{else:}
  \begin{itemize}
      \item \texttt{a > b} (3 $>$ 6) returns False, so the else block executes.
  \end{itemize}
  \item \texttt{b = b-a}
  \begin{itemize}
      \item \texttt{b} is now assigned to $6 - 3$, which is $3$.
  \end{itemize}
  \item \texttt{while a != b:}
  \begin{itemize}
      \item The while loop condition returns False (\texttt{3 == 3}), so the loop ends.
  \end{itemize}
  \item \texttt{return a}
  \begin{itemize}
      \item \texttt{a} is returned from the function, giving the correct greatest common divisor of \textbf{3}.
  \end{itemize}
\end{enumerate}
\subsection{Week 2}


The following are implementations of various functions in Haskell. \newline

% select_evens function
\noindent \texttt{select\_evens}, lists the even-indexed elements of a given list:
\begin{lstlisting}[language=Haskell]
-- Implementation
select_evens [] = [] -- in the case of a list with even number elements
select_evens (x:[]) = [] -- in the case of a list with odd number elements
select_evens (x:y:xs) = y : select_evens (xs)

-- Execution Sequence with example ["a","b","c","d","e"]
select_evens ["a","b","c","d","e"] =
    "b" : (select_evens["c","d","e"]) = 
    "b" : ("d" : (select_evens["e"])) =
    "b" : ("d" : ([])) = 
    ["b","d"]
\end{lstlisting} 

% select_odds function
\noindent \texttt{select\_odds}, lists the odd-indexed elements of a given list:
\begin{lstlisting}[language=Haskell]
-- Implementation
select_odds [] = [] -- in the case of a list with even number elements
select_odds (x:[]) = [x] -- in the case of a list with odd number elements
select_odds (x:y:xs) = x : select_odds (xs)

-- Execution Sequence with example ["a","b","c","d","e"]
select_odds ["a","b","c","d","e"] =
    "a" : (select_odds["c","d","e"]) = 
    "a" : ("c" : (select_odds["e"])) =
    "a" : ("c" : ("e")) = 
    ["a","c","e"]
\end{lstlisting}

% member function
\noindent \texttt{member}, determines whether an element is part of a given list:
\begin{lstlisting}[language=Haskell]
-- Implementation
member a [] = False
member a (x:xs)
    | a==x = True
    | otherwise = member a (xs)

-- Execution Sequence with example 2 [5,2,6]
member 2 [5,2,6] =
    member 2 [2,6] = 
    True
\end{lstlisting}

\newpage % Temporary page break

% append function
\noindent \texttt{append}, appends a list to another list:
\begin{lstlisting}[language=Haskell]
-- Implementation
append [] ys = ys
append (x:xs) ys = x : append xs ys

-- Execution Sequence with example [1,2] [3,4,5]
append [1,2] [3,4,5] =
    1 : (append [2] [3,4,5]) = 
    1 : (2 : (append [] [3,4,5])) =
    1 : (2 : ([3,4,5])) =
    [1,2,3,4,5]
\end{lstlisting}

% revert function
\noindent \texttt{revert}, reverses a list:
\begin{lstlisting}[language=Haskell]
-- Implementation
revert [] = []
revert (x:xs) = append (revert(xs)) [x]

-- Execution Sequence with example [1,2,3]
revert [1,2,3] =
    append (revert [2,3]) [1] =
    append (append (revert [3]) [2]) [1] =
    append (append (append (revert []) [3]) [2]) [1] =
    append (append (append [] [3]) [2]) [1] =
    append (append [3] [2]) [1] = 
    append (3 : (append [] [2])) [1] =
    append (3 : [2]) [1] =
    append [3,2] [1] =
    3 : (append [2] [1]) =
    3 : (2 : (append [] [1]) =
    3 : (2 : [1]) =
    [3,2,1]
\end{lstlisting}

% less_equal function
\noindent \texttt{less\_equal}, checks if the element in a list is less than or equal to the same-indexed element in another list:
\begin{lstlisting}[language=Haskell]
-- Implementation
less_equal [] [] = True
less_equal (x:xs) (y:ys)
    | x > y = False
    | otherwise = less_equal (xs) (ys)

-- Execution Sequence with example [1,2,3] [2,3,2]
less_equal [1,2,3] [2,3,2] =
    less_equal [2,3] [3,2] = 
    less_equal [3] [2] = 
    False
\end{lstlisting}

\newpage % Temporary page break
\subsection{Week 3}

The following investigates the Tower of Hanoi problem. Here is a given Haskell implementation describing moves in the game, as well as the execution sequence for the test input \texttt{hanoi 5 0 2}.
\begin{lstlisting}[language=Haskell]
-- Implementation
hanoi 1 x y = move x y

hanoi (n+1) x y = 
    hanoi n x (other x y) 
    move x y 
    hanoi n (other x y) y

-- Execution Sequence
hanoi 5 0 2
    hanoi 4 0 1
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{lstlisting} 
From this execution, the moves for a 5-ring Tower of Hanoi game can be seen as follows:
\begin{lstlisting}
0->2, 0->1, 2->1, 0->2, 1->0, 1->2, 0->2, 0->1, 2->1, 2->0, 1->0, 2->1, 0->2, 0->1, 2->1, 0->2, 1->0, 1->2, 0->2, 1->0, 2->1, 2->0, 1->0, 1->2, 0->2, 0->1, 2->1, 0->2, 1->0, 1->2, 0->2
\end{lstlisting}

\noindent \textbf{Analysis:} From this computation, the word \texttt{hanoi} appears exactly 31 times in the execution. Based on executions of the game with a different number of starting rings, the formula $2^n - 1$ can be derived to determine how many times \texttt{hanoi} will appear, with \texttt{n} being the number of disks in the game.


\section{Project}

To be written at a later date.

\section{Conclusions}\label{conclusions}

To be written at a later date.

\end{document}